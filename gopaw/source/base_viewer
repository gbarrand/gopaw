// Copyright (C) 2018, Guy Barrand. All rights reserved.
// See the file gopaw.license for terms.

#ifndef gopaw_base_viewer
#define gopaw_base_viewer

#include "iui"

#include <exlib/sg/gl2ps_action>

#include <exlib/jpeg>
#include <exlib/png>
#include <exlib/sg/text_freetype>

#include <inlib/sg/ortho>
#include <inlib/sg/zb_action>
#include <inlib/wps>

namespace gopaw {

class base_viewer : public virtual iwidget {
public:
  virtual inlib::sg::plots* plots(bool& a_created) const {a_created = false;return (inlib::sg::plots*)&m_plots;}
  virtual bool size(unsigned int& a_w,unsigned int& a_h) {a_w = m_width;a_h = m_height;return true;}
  virtual bool write(const std::string& a_file,const std::string& a_format,const std::string& /*a_opts*/ = "") {
    if(!m_scene_graph) return false;
    if(!m_width || !m_height) return false;
    if(a_format=="GL2PS_EPS") {
      exlib::sg::gl2ps_action action(m_gl2ps_mgr,m_out,m_width,m_height);
      if(!action.open(a_file,GL2PS_EPS)) return false;
      m_scene_graph->render(action);
      action.close();
    } else if(a_format=="GL2PS_PS") {
      exlib::sg::gl2ps_action action(m_gl2ps_mgr,m_out,m_width,m_height);
      if(!action.open(a_file,GL2PS_PS)) return false;
      m_scene_graph->render(action);
      action.close();
    } else if(a_format=="GL2PS_PDF") {
      exlib::sg::gl2ps_action action(m_gl2ps_mgr,m_out,m_width,m_height);
      if(!action.open(a_file,GL2PS_PDF)) return false;
      m_scene_graph->render(action);
      action.close();
    } else if(a_format=="GL2PS_SVG") {
      exlib::sg::gl2ps_action action(m_gl2ps_mgr,m_out,m_width,m_height);
      if(!action.open(a_file,GL2PS_SVG)) return false;
      m_scene_graph->render(action);
      action.close();
    } else if(a_format=="GL2PS_TEX") {
      exlib::sg::gl2ps_action action(m_gl2ps_mgr,m_out,m_width,m_height);
      if(!action.open(a_file,GL2PS_TEX)) return false;
      m_scene_graph->render(action);
      action.close();
    } else if(a_format=="GL2PS_PGF") {
      exlib::sg::gl2ps_action action(m_gl2ps_mgr,m_out,m_width,m_height);
      if(!action.open(a_file,GL2PS_PGF)) return false;
      m_scene_graph->render(action);
      action.close();
      
    } else {
      inlib::sg::zb_action action(m_zb_mgr,m_out,m_width,m_height);
      inlib::colorf clear_color = inlib::colorf_white();
      action.zbuffer().clear_color_buffer(0);
      action.add_color(clear_color.r(),clear_color.g(),clear_color.b());
      action.zbuffer().clear_depth_buffer();    
      m_scene_graph->render(action);
      if(a_format=="INZB_PS") {
        inlib::wps wps(m_out);
        if(!wps.open_file(a_file)) {
          m_out << "gopaw::base_viewer::write : can't open " << a_file << "." << std::endl;
          return false;
        }
        wps.PS_BEGIN_PAGE();
        wps.PS_PAGE_SCALE(float(m_width),float(m_height));
        wps.PS_IMAGE(m_width,m_height,inlib::wps::rgb_4,inlib::sg::zb_action::get_rgb,&action);
        wps.PS_END_PAGE();
        wps.close_file();
      
      } else {
        inlib::byte* buffer = new inlib::byte[3*m_width*m_height];
       {inlib::sg::zb_action::VCol r,g,b;
        inlib::byte* pos = buffer;
        for(int row=m_height-1;row>=0;row--) {
        for(unsigned int col=0;col<m_width;col++) {
          inlib::sg::zb_action::get_rgb(&action,col,row,r,g,b);
          *pos = inlib::byte(255.0f*r);pos++;
          *pos = inlib::byte(255.0f*g);pos++;
          *pos = inlib::byte(255.0f*b);pos++;
         }}}
  
        if(a_format=="INZB_JPEG") {
          if(!exlib::jpeg::write(m_out,a_file,buffer,m_width,m_height,3,100)) {
            m_out << "gopaw::base_viewer::write : exlib::jpeg::write() failed." << std::endl;
            delete [] buffer;
            return false;
          }
        } else if(a_format=="INZB_PNG") {
          if(!exlib::png::write(m_out,a_file,buffer,m_width,m_height,3)) {
            m_out << "gopaw::base_viewer::write : exlib::png::write() failed." << std::endl;
            delete [] buffer;
            return false;
          }
        } else {
          m_out << "gopaw::base_viewer::write : unknown format " << a_format << std::endl;
	}
        delete [] buffer;
      }
    }
    return true;
  }
public:
  base_viewer(std::ostream& a_out,unsigned int a_width,unsigned int a_height)
  :m_out(a_out)
  ,m_width(a_width)
  ,m_height(a_height)
  ,m_ttf()
  ,m_camera()
  ,m_plots(m_ttf)  
  ,m_scene_graph(0)
  {
  //m_light.direction = inlib::vec3f(1,-1,-10);
  //m_light.on = false;

    inlib::sg::plotter& plotter = m_plots.current_plotter();
    m_camera.height = 20; //YSIZ
    float z = 10*plotter.depth.value(); //large to handle plotter::shape=xyz.
    m_camera.position = inlib::vec3f(0,0,z);
    m_camera.znear = 0.01f*z;
    m_camera.zfar = 100*z;
    m_camera.focal = z;
    _set_size(a_width,a_height); //it sets m_camera.height.
    
  }
  virtual ~base_viewer() {}
public:
protected:
  base_viewer(const base_viewer& a_from)
  :iwidget(a_from)
  ,m_out(a_from.m_out)
  ,m_width(a_from.m_width)
  ,m_height(a_from.m_height)
  ,m_ttf()
  ,m_camera(a_from.m_camera)
  ,m_plots(a_from.m_plots)  
  ,m_scene_graph(0)
  {}
  base_viewer& operator=(const base_viewer& a_from){
    m_width = a_from.m_width;
    m_height = a_from.m_height;
    m_camera = a_from.m_camera;
    return *this;
  }
public:
  void set_viewer_scene_graph(inlib::sg::group* a_viewer_sg) {m_scene_graph = a_viewer_sg;}
  void set_scene_graph(inlib::sg::group& a_group) {
    a_group.add(new inlib::sg::noderef(m_camera));
  //a_group.add(new inlib::sg::noderef(m_light));
    a_group.add(new inlib::sg::noderef(m_plots));
  }
protected:
  void _set_size(unsigned int a_w,unsigned int a_h) {
    if(!a_w||!a_h) return;    
    m_width = a_w;
    m_height = a_h;
    float aspect = float(a_w)/float(a_h);
    if(aspect>=1) {
      m_camera.height = 20;
    } else {
      m_camera.height = 20/aspect;
    }
  }
protected:
  std::ostream& m_out;
  unsigned int m_width;
  unsigned int m_height;
  exlib::sg::text_freetype m_ttf;
  inlib::sg::ortho m_camera;
//inlib::sg::head_light m_light;
  inlib::sg::plots m_plots;
  inlib::sg::group* m_scene_graph;
  inlib::sg::zb_manager m_zb_mgr;
  exlib::sg::gl2ps_manager m_gl2ps_mgr;
};

}

#endif
